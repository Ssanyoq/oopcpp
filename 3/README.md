# PREAMBLE

## Общие требования:
1) Проект на git'е.
2) Наличие интерактивного диалогового интерфейса для проверки корректности разработанной
программы.
3) Корректное завершение программы, как в случае штатного выхода, так и в случае
невосстановимых ошибок (без утечек и без использования функций мгновенного завершения
программы `exit`, `abort`, `std::terminate` и пр.).
4) Проверка корректности ввода (работа только через потоки C++, т. е. без
`scanf`/`printf`/`fscanf`/`fprintf`). В случаях ошибок формата ввода запрос повторного ввода данных. В
случае невосстановимых ошибок ввода-вывода завершение программы.
5) Использование средств языка C++ для работы с динамической памятью – операторов `new` и
`delete` (`malloc`, `calloc`, `realloc`, `free` запрещены).
6) Использование исключений для обработки ошибочных ситуаций (вместо кодов возврата).
7) Предпочтительно использование стандартных библиотек и функций языка C++ вместо
библиотек и функций языка C (`std::copy` вместо `memcpy`, `std::abs` вместо `abs`, `cstring` вместо
`string.h` и т.д.).
8) Логичная и удобная структура проекта, где каждая единица (файл/библиотека) обладает своей
единой зоной ответственности (каждый класс в своих файлах `.h` и `.cpp`, диалоговые функции и
`main` в своих).
9) Наличие средств автосборки проекта (желательно CMake, qmake и прочие, работающие
“поверх” Makefile; использование самописного Makefile нежелательно, но допустимо).
10) Статический анализ кода, встроенный инструментарий в IDE (пр. VS2019: Analyze->Run
Code Analysis, см. также Project -> Properties -> Configuration Properties -> Code Analysis ->
Microsoft -> Active Rules) или внешние инструменты (Sonarqube + extensions, Clang Static
Analyzer и д.р.) (обязательно знакомство с инструментом, исправление всех замечаний или
обоснование в комментарии почему конкретное замечание исправить нельзя).
11) Динамический анализ на утечки памяти, встроенный инструментарий в IDE / библиотеки
(Пр., VS2019) или внешние инструменты (`valgrind`, `Deleaker` и т.п.). Отсутствие утечек памяти и
прочих замечаний анализатора.
12) Не "кривой", не избыточный, поддерживаемый и расширяемый код (разумная декомпозиция,
DRY, корректное использование заголовочных файлов и т.п.).
13) Стандарт языка C++20 (рекомендуется). Допустим C++17 (если почему-то нет С++20).
## Требования задачи:
1) На выбор предоставляется две категории вариантов: простые и сложные. Сложные варианты
обладают дополнительным множителем для баллов, получаемых за пункты задания «UML»,
«Реализация», «Прикладная программа», «Тестирование» и «Многопоточность». Множитель,
указанный в варианте, является ориентировочным и может меняться по усмотрению
преподавателя. При выборе варианта также обратите внимание на то, что для простых вариантов
отсутствуют дополнительные задания «динамическая загрузка» и «плагины».
2) Разработка модульных тестов для классов, удовлетворительное (не менее 50%) покрытие
методов классов модульными тестами.
3) Использование фреймворков для тестирования решения (`gtest`, `catch2` и пр.). Тестирование
встроенными средствами языка запрещено.
4) Логичная структура решения, разделение на зоны ответственность (отдельные компоненты
вынести в отдельные библиотеки), следование принципам SOLID.
5) Документирование всех публичных методов шаблонного и расширяемого классов (для
простых вариантов — всех классов) с использованием doxygen. Документация метода должна
включать в себя как минимум описание всех аргументов метода, описание возвращаемого
значения и описание всех исключений, которые могут быть выброшены в этом методе (для
каждого указать тип исключения и в каких случаях оно может возникнуть).
6) Корректность состояния классов, отсутствие избыточности, наличие необходимых
конструкторов и деструктора, корректность сигнатуры методов, сохранение семантики
перегружаемых операторов и корректность их сигнатуры, сохранение семантики работы с
потоками ввода/вывода для перегружаемых операторов сдвига.
7) Строгое следование схемам MVC или MVP при проектировании программы. То есть классы
программы необходимо разделить на 3 категории (библиотеки):
- Классы внутренней логики программы (model);
- классы отображения (view);
- классы управления/представления (controller/presenter).
Допускаются объединение view и controller/presenter в один компонент.
8) Динамический анализ (thread sanitizer и т.п.) многопоточной программы на отсутствие
состязаний (race condidion). Наличие состязаний в финальной версии программы не
допускается.
9) Основной язык программирования — C++. По согласованию с преподавателем,
принимающим лабораторные работы, допускается использование Java или C#.

## Порядок выполнения работы:
1) UML. Выполнить проектирование диаграммы классов реализуемой программы в нотации UML
(рекомендуется использовать специализированный редактор, например, modelio) и разработку
соответствующих диаграмме прототипов классов (хедеров). Допустима генерация UMLдиаграммы из кода или кода из UML-диаграммы, однако в любом случае диаграмма классов и их
прототипы должны полностью соответствовать друг другу.
2) Реализация. Выполнить реализацию всех классов, отвечающих за логику программы. Для
проверки реализованных классов использовать тесты или простую проверочную main функцию.
3) Прикладная программа. Реализовать прикладную программу для работы с разработанными
классами. Возможно выполнение пункта в 1 из 3 вариантов:
- диалоговая программа (до 2 баллов);
- псевдографическая программа (обязательно интерактивное навигирование при помощи
клавиш без нажатия Enter, например, с использованием библиотеки ncurses)
(до 5 баллов);
- графическая программа (до 8 баллов).
4) Шаблон. Выполнить реализацию указанного в задании контейнера в виде шаблонного класса.
Разработанный шаблонный класс должен обладать основными методами (вставка, поиск,
удаление и т.д.) и предоставлять полноценный интерфейс доступа при помощи итераторов.
Класс итератора должен соответствовать выбранной категории (`random access`, `bidirectional`,
`forward` или прочие). Выбор категории итератора необходимо обосновать. В учебных целях, при
реализации своего шаблонного контейнера, запрещается использовать контейнеры STL.
Использовать умные указатели можно.
5) Тестирование. Разработать тесты для классов логики. Написание unit тестов для интерфейса
пользователя (контроллера/представления и отображения) не требуется.
Документация. Составить документацию для расширяемого и шаблонного классов (см.
требования). Для простых вариантов вместо этого составить документацию для всех
разработанных классов логики. Документировать классы пользовательского интерфейса не
требуется.
6) Многопоточность. Модифицировать программу таким образом, чтобы указанный в задании
алгоритм выполнятся параллельно в несколько потоков. Необходимо использовать
предоставляемые языком примитивы синхронизации для избежания состязаний. Сравнить
скорость выполнения одной и той же операции в однопоточном и многопоточном режимах в
зависимости от объёма данных (построить график).
7) Динамическая загрузка*. Обеспечить динамическую загрузку для наследников расширяемого
(см. в задании) класса из динамических библиотек (`.so`/`.dll`). При запуске программа должна
загружать все библиотеки, представленные в некотором каталоге, считывать их метаинформацию
и использовать при дальнейшей работы. Перенести всех реализованных
наследников расширяемого класса в динамические библиотеки в качестве примера.
8) Плагин*. Обменяться своим кодом с другими студентами и выполнить реализацию своего
плагина для кода другого студента. Плагин представляет из себя новог наследника
расширяемого класса, собранного в виде динамической библиотеки. Модифицировать код
другого студента не допускается.

Примечание: Пункты задания от «UML» до «Прикладная программа» необходимо выполнять и
сдавать строго в указанной последовательности. Приступать к выполнению следующего пункта
до сдачи предыдущего крайне не рекомендуется, так как при обнаружении ошибок на более
ранних этапах придётся переделывать всю программу целиком от первых и до последних
этапов.

---
# TASK
В данной игре поджанра Tower Defence игровой процесс происходит на местности, покрытой дорогой, полями и лесами. Враги, порождаемые расположенными на карте логовами, пытаются по дороге добраться до замка игрока и нанести ему урон. Цель врагов - уничтожить замок, цель игрока - не позволить им это сделать.

Для защиты замка игрок может за золото установить на карте следующие виды башен3: простая башня, магическая башня, магическая ловушка. Простая и магическая башни наносят урон врагам попавшим в радиус действия в соответствии с установленной стратегией: ближайший к башне, ближайший к замку, наиболее слабый, наиболее сильный, наиболее быстрый и т. п. Башни могут быть построены только в поле. Магическая башня при попадании во врага не только наносит урон, но и накладывает на него некоторый магический эффект. Магическая ловушка устанавливается на дороге и срабатывает при наступании на неё врага. При срабатывании ловушки, на всех врагов в определённом радиусе накладывается магический эффект.

Каждый наложенный магический эффект имеет некоторую величину эффекта (показатель силы эффекта) и время действия. Существуют следующие типы магических эффектов: замедление (скорость передвижения врага уменьшается на процент величины эффекта), отравление (враг теряет количество здоровья в единицу времени равное величине эффекта), ослабление (урон наносимый врагу увеличивается на процент величины эффекта). Все эффекты суммируются.

Враги перемещаются от логова к замку только по дороге. Расчёт текущего здоровья врага осуществляется в зависимости от эффектов и нанесенного ему урона. Если здоровье врага становится меньше или равно 0, то он погибает, а замку начисляется запас золота врага. Если врагу удастся дойти до замка, он наносит ему урон, равный количеству оставшегося здоровья врага, после чего погибает, но золото замку не начисляется.

Разработать приложение, позволяющее описывать состояние игры типа Tower Defense, в которое должно входить информация о врагах, защитных постройках, замке и ландшафте. Обеспечить загрузку информации о типах врагов, таблицах улучшений и стоимости построек из конфигурационных файлов, загрузку карты из файлов карты, а также возможность загрузки и сохранения текущего состояния приложения на диск. Для хранения в памяти информации о врагах, защитных постройках и замке используются соответствующие описатели. Описатель замка содержит следующую информацию: название замка,
текущую и максимальную прочность, количество золота.

Описатель эффекта содержит оставшееся время действия эффекта, тип и величину эффекта.

Описатель врага содержит название, максимальное и текущий запас здоровья, количество золота, скорость передвижения, и таблицу эффектов.

Описатель логова содержит таблицу описателей врагов и время их выхода из логова.

Описатель башни содержит следующую информацию: уровень башни и таблицу характеристик башни соответствующую уровню: стоимость, радиус действия, наносимый урон и скорострельность. Дополнительно в таблице характеристик присутствует описатель эффекта, накладываемый магической башней.

Ландшафт (уровень) представляет собой таблицу расположения врагов и прямоугольное поле1, разделенное на клетки: дорога, поле, лес. Каждая клетка может указывать на описатель строения, стоящего на нём: замок, логова врагов, защитные башни; ловушки.

Обеспечить выполнение как минимум следующих операций, при помощи которых можно реализовать процесс игры:
1) Для ландшафта (уровня):
- получение/изменение размеров игрового поля;
-  получение/изменение типа клетки с заданной координатой в процессе конструирования уровня и в процессе игры;
- проверка корректности уровня (наличие одного замка и минимум одного логова, от всех логов до замка должна быть проложена дорога).
2) Для врага:
- сделать очередной ход (приблизиться к замку и рассчитать здоровье).
3) Для таблицы:
- получить количество эффектов у врага;
- добавить эффект врагу в таблицу.
4) Для башни:
- повысить уровень башни;
- нанести урон врагам в соответствии со стратегией.
5) Для замка
- нанести урон замку.
6) Для логова
- выпустить очередного врага;
- выпустить очередного врага, если подошло его время выхода из логова.
7) Для игры
- совершить ход — передвинуть всех врагов и осуществить выстрел для каждой башни2
  
1. Шаблонный класс — матрица (обращение к элементам - `matr[i][j]`).
2. Указанную операцию реализовать в многопоточном режиме. Каждая группа башен и врагов обрабатывается в отдельном потоке.
3. Расширяемый класс — башня. Необходимо предусмотреть возможность переопределения основных операций башни в новом классе - наследнике (например, башня с аурой, которая каждый ход накладывает магический эффект на всех врагов, находящихся в некотором радиусе, и при этом не уничтожается).
